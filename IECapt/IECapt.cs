////////////////////////////////////////////////////////////////////
//
// IECapt# - A Internet Explorer Web Page Rendering Capture Utility
//
// Copyright (C) 2007 Bjoern Hoehrmann <bjoern@hoehrmann.de>
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// $Id$
//
////////////////////////////////////////////////////////////////////

using System;
using System.Drawing;
using System.Drawing.Imaging;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using System.Windows.Forms;
using AxSHDocVw; // Use `aximp %SystemRoot%\system32\shdocvw.dll`
using mshtml;    // Add "Microsoft.mshtml" (.NET)

// Various COM interface and struct declarations. Many of them are not
// strictly necessary, only IViewObject, IDocHostUIHandler, ICustomDoc,
// _DOCHOSTUIINFO, and _RECTL. Removing the others would require re-
// writing the prototypes of some of them and would make adaptions more
// difficult. The declarations have been generated by midl and tlbimp.

[ComImport, InterfaceType((short) 1), Guid("0000010F-0000-0000-C000-000000000046"), ComConversionLoss]
public interface IAdviseSink {
  void RemoteOnDataChange([In] ref tagFORMATETC pformatetc, [In] IntPtr pStgmed);
  void RemoteOnViewChange([In] uint dwAspect, [In] int lindex);
  void RemoteOnRename([In, MarshalAs(UnmanagedType.Interface)] IMoniker pmk);
  void RemoteOnSave();
  void RemoteOnClose();
}


[ComImport, Guid("0000000E-0000-0000-C000-000000000046"), InterfaceType((short) 1)]
public interface IBindCtx {
  void RegisterObjectBound([In, MarshalAs(UnmanagedType.IUnknown)] object punk);
  void RevokeObjectBound([In, MarshalAs(UnmanagedType.IUnknown)] object punk);
  void ReleaseBoundObjects();
  void RemoteSetBindOptions([In] ref tagBIND_OPTS2 pbindopts);
  void RemoteGetBindOptions([In, Out] ref tagBIND_OPTS2 pbindopts);
  void GetRunningObjectTable([MarshalAs(UnmanagedType.Interface)] out IRunningObjectTable pprot);
  void RegisterObjectParam([In, MarshalAs(UnmanagedType.LPWStr)] string pszKey, [In, MarshalAs(UnmanagedType.IUnknown)] object punk);
  void GetObjectParam([In, MarshalAs(UnmanagedType.LPWStr)] string pszKey, [MarshalAs(UnmanagedType.IUnknown)] out object ppunk);
  void EnumObjectParam([MarshalAs(UnmanagedType.Interface)] out IEnumString ppenum);
  void RevokeObjectParam([In, MarshalAs(UnmanagedType.LPWStr)] string pszKey);
}


[ComImport, Guid("0000012A-0000-0000-C000-000000000046"), InterfaceType((short) 1)]
public interface IContinue {
  void FContinue();
}


[ComImport, InterfaceType((short) 1), Guid("3050F3F0-98B5-11CF-BB82-00AA00BDCE0B")]
public interface ICustomDoc {
  void SetUIHandler([In, MarshalAs(UnmanagedType.Interface)] IDocHostUIHandler pUIHandler);
}


[ComImport, InterfaceType((short) 1), ComConversionLoss, Guid("0000010E-0000-0000-C000-000000000046")]
public interface IDataObject {
  void RemoteGetData([In] ref tagFORMATETC pformatetcIn, [Out] IntPtr pRemoteMedium);
  void RemoteGetDataHere([In] ref tagFORMATETC pformatetc, [In, Out] IntPtr pRemoteMedium);
  void QueryGetData([In] ref tagFORMATETC pformatetc);
  void GetCanonicalFormatEtc([In] ref tagFORMATETC pformatectIn, out tagFORMATETC pformatetcOut);
  void RemoteSetData([In] ref tagFORMATETC pformatetc, [In] IntPtr pmedium, [In] int fRelease);
  void EnumFormatEtc([In] uint dwDirection, [MarshalAs(UnmanagedType.Interface)] out IEnumFORMATETC ppenumFormatEtc);
  void DAdvise([In] ref tagFORMATETC pformatetc, [In] uint advf, [In, MarshalAs(UnmanagedType.Interface)] IAdviseSink pAdvSink, out uint pdwConnection);
  void DUnadvise([In] uint dwConnection);
  void EnumDAdvise([MarshalAs(UnmanagedType.Interface)] out IEnumSTATDATA ppenumAdvise);
}


[ComImport, InterfaceType((short) 1), Guid("BD3F23C0-D43E-11CF-893B-00AA00BDCE1A"), ComConversionLoss]
public interface IDocHostUIHandler {
  [PreserveSig]
  uint ShowContextMenu([In] uint dwID, [In] ref tagPOINT ppt, [In, MarshalAs(UnmanagedType.IUnknown)] object pcmdtReserved, [In, MarshalAs(UnmanagedType.IDispatch)] object pdispReserved);
  void GetHostInfo([In, Out] ref _DOCHOSTUIINFO pInfo);
  [PreserveSig]
  uint ShowUI([In] uint dwID, [In, MarshalAs(UnmanagedType.Interface)] IOleInPlaceActiveObject pActiveObject, [In, MarshalAs(UnmanagedType.Interface)] IOleCommandTarget pCommandTarget, [In, MarshalAs(UnmanagedType.Interface)] IOleInPlaceFrame pFrame, [In, MarshalAs(UnmanagedType.Interface)] IOleInPlaceUIWindow pDoc);
  void HideUI();
  void UpdateUI();
  void EnableModeless([In] int fEnable);
  void OnDocWindowActivate([In] int fActivate);
  void OnFrameWindowActivate([In] int fActivate);
  void ResizeBorder([In] ref tagRECT prcBorder, [In, MarshalAs(UnmanagedType.Interface)] IOleInPlaceUIWindow pUIWindow, [In] int fRameWindow);
  [PreserveSig]
  void TranslateAccelerator([In] ref tagMSG lpmsg, [In] ref Guid pguidCmdGroup, [In] uint nCmdID);
  void GetOptionKeyPath([MarshalAs(UnmanagedType.LPWStr)] out string pchKey, [In] uint dw);
  void GetDropTarget([In, MarshalAs(UnmanagedType.Interface)] IDropTarget pDropTarget, [MarshalAs(UnmanagedType.Interface)] out IDropTarget ppDropTarget);
  [PreserveSig]
  void GetExternal([MarshalAs(UnmanagedType.IDispatch)] out object ppDispatch);
  [PreserveSig]
  uint TranslateUrl([In] uint dwTranslate, [In, MarshalAs(UnmanagedType.BStr)] string pchURLIn, [In, Out, MarshalAs(UnmanagedType.BStr)] ref string ppchURLOut);
  uint FilterDataObject([In, MarshalAs(UnmanagedType.Interface)] IDataObject pDO, [MarshalAs(UnmanagedType.Interface)] out IDataObject ppDORet);
}


[ComImport, InterfaceType((short) 1), Guid("00000122-0000-0000-C000-000000000046")]
public interface IDropTarget {
  void DragEnter([In, MarshalAs(UnmanagedType.Interface)] IDataObject pDataObj, [In] uint grfKeyState, [In] _POINTL pt, [In, Out] ref uint pdwEffect);
  void DragOver([In] uint grfKeyState, [In] _POINTL pt, [In, Out] ref uint pdwEffect);
  void DragLeave();
  void Drop([In, MarshalAs(UnmanagedType.Interface)] IDataObject pDataObj, [In] uint grfKeyState, [In] _POINTL pt, [In, Out] ref uint pdwEffect);
}


[ComImport, InterfaceType((short) 1), Guid("00000103-0000-0000-C000-000000000046")]
public interface IEnumFORMATETC {
  void RemoteNext([In] uint celt, out tagFORMATETC rgelt, out uint pceltFetched);
  void Skip([In] uint celt);
  void Reset();
  void Clone([MarshalAs(UnmanagedType.Interface)] out IEnumFORMATETC ppenum);
}


[ComImport, Guid("00000102-0000-0000-C000-000000000046"), InterfaceType((short) 1)]
public interface IEnumMoniker {
  void RemoteNext([In] uint celt, [MarshalAs(UnmanagedType.Interface)] out IMoniker rgelt, out uint pceltFetched);
  void Skip([In] uint celt);
  void Reset();
  void Clone([MarshalAs(UnmanagedType.Interface)] out IEnumMoniker ppenum);
}


[ComImport, Guid("00000105-0000-0000-C000-000000000046"), InterfaceType((short) 1)]
public interface IEnumSTATDATA {
  void RemoteNext([In] uint celt, out tagSTATDATA rgelt, out uint pceltFetched);
  void Skip([In] uint celt);
  void Reset();
  void Clone([MarshalAs(UnmanagedType.Interface)] out IEnumSTATDATA ppenum);
}


[ComImport, Guid("00000101-0000-0000-C000-000000000046"), InterfaceType((short) 1)]
public interface IEnumString {
  void RemoteNext([In] uint celt, [MarshalAs(UnmanagedType.LPWStr)] out string rgelt, out uint pceltFetched);
  void Skip([In] uint celt);
  void Reset();
  void Clone([MarshalAs(UnmanagedType.Interface)] out IEnumString ppenum);
}


[ComImport, InterfaceType((short) 1), Guid("0000000F-0000-0000-C000-000000000046")]
public interface IMoniker : IPersistStream {
  void RemoteBindToObject([In, MarshalAs(UnmanagedType.Interface)] IBindCtx pbc, [In, MarshalAs(UnmanagedType.Interface)] IMoniker pmkToLeft, [In] ref Guid riidResult, [MarshalAs(UnmanagedType.IUnknown)] out object ppvResult);
  void RemoteBindToStorage([In, MarshalAs(UnmanagedType.Interface)] IBindCtx pbc, [In, MarshalAs(UnmanagedType.Interface)] IMoniker pmkToLeft, [In] ref Guid riid, [MarshalAs(UnmanagedType.IUnknown)] out object ppvObj);
  void Reduce([In, MarshalAs(UnmanagedType.Interface)] IBindCtx pbc, [In] uint dwReduceHowFar, [In, Out, MarshalAs(UnmanagedType.Interface)] ref IMoniker ppmkToLeft, [MarshalAs(UnmanagedType.Interface)] out IMoniker ppmkReduced);
  void ComposeWith([In, MarshalAs(UnmanagedType.Interface)] IMoniker pmkRight, [In] int fOnlyIfNotGeneric, [MarshalAs(UnmanagedType.Interface)] out IMoniker ppmkComposite);
  void Enum([In] int fForward, [MarshalAs(UnmanagedType.Interface)] out IEnumMoniker ppenumMoniker);
  void IsEqual([In, MarshalAs(UnmanagedType.Interface)] IMoniker pmkOtherMoniker);
  void Hash(out uint pdwHash);
  void IsRunning([In, MarshalAs(UnmanagedType.Interface)] IBindCtx pbc, [In, MarshalAs(UnmanagedType.Interface)] IMoniker pmkToLeft, [In, MarshalAs(UnmanagedType.Interface)] IMoniker pmkNewlyRunning);
  void GetTimeOfLastChange([In, MarshalAs(UnmanagedType.Interface)] IBindCtx pbc, [In, MarshalAs(UnmanagedType.Interface)] IMoniker pmkToLeft, out _FILETIME pfiletime);
  void Inverse([MarshalAs(UnmanagedType.Interface)] out IMoniker ppmk);
  void CommonPrefixWith([In, MarshalAs(UnmanagedType.Interface)] IMoniker pmkOther, [MarshalAs(UnmanagedType.Interface)] out IMoniker ppmkPrefix);
  void RelativePathTo([In, MarshalAs(UnmanagedType.Interface)] IMoniker pmkOther, [MarshalAs(UnmanagedType.Interface)] out IMoniker ppmkRelPath);
  void GetDisplayName([In, MarshalAs(UnmanagedType.Interface)] IBindCtx pbc, [In, MarshalAs(UnmanagedType.Interface)] IMoniker pmkToLeft, [MarshalAs(UnmanagedType.LPWStr)] out string ppszDisplayName);
  void ParseDisplayName([In, MarshalAs(UnmanagedType.Interface)] IBindCtx pbc, [In, MarshalAs(UnmanagedType.Interface)] IMoniker pmkToLeft, [In, MarshalAs(UnmanagedType.LPWStr)] string pszDisplayName, out uint pchEaten, [MarshalAs(UnmanagedType.Interface)] out IMoniker ppmkOut);
  void IsSystemMoniker(out uint pdwMksys);
}


[ComImport, Guid("B722BCCB-4E68-101B-A2BC-00AA00404770"), InterfaceType((short) 1)]
public interface IOleCommandTarget {
  void QueryStatus([In] ref Guid pguidCmdGroup, [In] uint cCmds, [In, Out] ref _tagOLECMD prgCmds, [In, Out] ref _tagOLECMDTEXT pCmdText);
  void Exec([In] ref Guid pguidCmdGroup, [In] uint nCmdID, [In] uint nCmdexecopt, [In, MarshalAs(UnmanagedType.Struct)] ref object pvaIn, [In, Out, MarshalAs(UnmanagedType.Struct)] ref object pvaOut);
}


[ComImport, InterfaceType((short) 1), Guid("00000117-0000-0000-C000-000000000046")]
public interface IOleInPlaceActiveObject : IOleWindow {
  void RemoteTranslateAccelerator();
  void OnFrameWindowActivate([In] int fActivate);
  void OnDocWindowActivate([In] int fActivate);
  void RemoteResizeBorder([In] ref tagRECT prcBorder, [In] ref Guid riid, [In, MarshalAs(UnmanagedType.Interface)] IOleInPlaceUIWindow pUIWindow, [In] int fFrameWindow);
  void EnableModeless([In] int fEnable);
}


[ComImport, InterfaceType((short) 1), Guid("00000116-0000-0000-C000-000000000046")]
public interface IOleInPlaceFrame : IOleInPlaceUIWindow {
  void InsertMenus([In] ref _RemotableHandle hmenuShared, [In, Out] ref tagOleMenuGroupWidths lpMenuWidths);
  void SetMenu([In] ref _RemotableHandle hmenuShared, [In] ref _userHGLOBAL holemenu, [In] ref _RemotableHandle hwndActiveObject);
  void RemoveMenus([In] ref _RemotableHandle hmenuShared);
  void SetStatusText([In, MarshalAs(UnmanagedType.LPWStr)] string pszStatusText);
  void EnableModeless([In] int fEnable);
  void TranslateAccelerator([In] ref tagMSG lpmsg, [In] ushort wID);
}


[ComImport, Guid("00000115-0000-0000-C000-000000000046"), InterfaceType((short) 1)]
public interface IOleInPlaceUIWindow : IOleWindow {
  void GetBorder(out tagRECT lprectBorder);
  void RequestBorderSpace([In] ref tagRECT pborderwidths);
  void SetBorderSpace([In] ref tagRECT pborderwidths);
  void SetActiveObject([In, MarshalAs(UnmanagedType.Interface)] IOleInPlaceActiveObject pActiveObject, [In, MarshalAs(UnmanagedType.LPWStr)] string pszObjName);
}


[ComImport, Guid("00000114-0000-0000-C000-000000000046"), InterfaceType((short) 1), ComConversionLoss]
public interface IOleWindow {
  void GetWindow([Out] IntPtr phwnd);
  void ContextSensitiveHelp([In] int fEnterMode);
}


[ComImport, InterfaceType((short) 1), Guid("0000010C-0000-0000-C000-000000000046")]
public interface IPersist {
  void GetClassID(out Guid pClassID);
}


[ComImport, InterfaceType((short) 1), Guid("00000109-0000-0000-C000-000000000046")]
public interface IPersistStream : IPersist {
  void IsDirty();
  void Load([In, MarshalAs(UnmanagedType.Interface)] IStream pstm);
  void Save([In, MarshalAs(UnmanagedType.Interface)] IStream pstm, [In] int fClearDirty);
  void GetSizeMax(out _ULARGE_INTEGER pcbSize);
}


[ComImport, InterfaceType((short) 1), Guid("00000010-0000-0000-C000-000000000046")]
public interface IRunningObjectTable {
  void Register([In] uint grfFlags, [In, MarshalAs(UnmanagedType.IUnknown)] object punkObject, [In, MarshalAs(UnmanagedType.Interface)] IMoniker pmkObjectName, out uint pdwRegister);
  void Revoke([In] uint dwRegister);
  void IsRunning([In, MarshalAs(UnmanagedType.Interface)] IMoniker pmkObjectName);
  void GetObject([In, MarshalAs(UnmanagedType.Interface)] IMoniker pmkObjectName, [MarshalAs(UnmanagedType.IUnknown)] out object ppunkObject);
  void NoteChangeTime([In] uint dwRegister, [In] ref _FILETIME pfiletime);
  void GetTimeOfLastChange([In, MarshalAs(UnmanagedType.Interface)] IMoniker pmkObjectName, out _FILETIME pfiletime);
  void EnumRunning([MarshalAs(UnmanagedType.Interface)] out IEnumMoniker ppenumMoniker);
}


[ComImport, Guid("0C733A30-2A1C-11CE-ADE5-00AA0044773D"), InterfaceType((short) 1)]
public interface ISequentialStream {
  void RemoteRead(out byte pv, [In] uint cb, out uint pcbRead);
  void RemoteWrite([In] ref byte pv, [In] uint cb, out uint pcbWritten);
}


[ComImport, Guid("0000000C-0000-0000-C000-000000000046"), InterfaceType((short) 1)]
public interface IStream : ISequentialStream {
  void RemoteSeek([In] _LARGE_INTEGER dlibMove, [In] uint dwOrigin, out _ULARGE_INTEGER plibNewPosition);
  void SetSize([In] _ULARGE_INTEGER libNewSize);
  void RemoteCopyTo([In, MarshalAs(UnmanagedType.Interface)] IStream pstm, [In] _ULARGE_INTEGER cb, out _ULARGE_INTEGER pcbRead, out _ULARGE_INTEGER pcbWritten);
  void Commit([In] uint grfCommitFlags);
  void Revert();
  void LockRegion([In] _ULARGE_INTEGER libOffset, [In] _ULARGE_INTEGER cb, [In] uint dwLockType);
  void UnlockRegion([In] _ULARGE_INTEGER libOffset, [In] _ULARGE_INTEGER cb, [In] uint dwLockType);
  void Stat(out tagSTATSTG pstatstg, [In] uint grfStatFlag);
  void Clone([MarshalAs(UnmanagedType.Interface)] out IStream ppstm);
}


[ComImport, Guid("0000010D-0000-0000-C000-000000000046"), InterfaceType((short) 1), ComConversionLoss]
public interface IViewObject {
  //void Draw([In] uint dwDrawAspect, [In] int lindex, [In] uint pvAspect, [In] IntPtr ptd, [In] uint hdcTargetDev, [In] uint hdcDraw, [In] ref _RECTL lprcBounds, [In] ref _RECTL lprcWBounds, [In, MarshalAs(UnmanagedType.Interface)] IContinue pContinue);

  void Draw([MarshalAs(UnmanagedType.U4)] UInt32 dwDrawAspect,
            int lindex,
            IntPtr pvAspect,
            [In] IntPtr ptd,
            IntPtr hdcTargetDev,
            IntPtr hdcDraw,
            [MarshalAs(UnmanagedType.Struct)] ref _RECTL lprcBounds,
            [In] IntPtr lprcWBounds,
            IntPtr pfnContinue,
            [MarshalAs(UnmanagedType.U4)] UInt32 dwContinue);

  void RemoteGetColorSet([In] uint dwDrawAspect, [In] int lindex, [In] uint pvAspect, [In] ref tagDVTARGETDEVICE ptd, [In] uint hicTargetDev, [Out] IntPtr ppColorSet);
  void RemoteFreeze([In] uint dwDrawAspect, [In] int lindex, [In] uint pvAspect, out uint pdwFreeze);
  void Unfreeze([In] uint dwFreeze);
  void SetAdvise([In] uint aspects, [In] uint advf, [In, MarshalAs(UnmanagedType.Interface)] IAdviseSink pAdvSink);
  void RemoteGetAdvise(out uint pAspects, out uint pAdvf, [MarshalAs(UnmanagedType.Interface)] out IAdviseSink ppAdvSink);
}


[ComImport, InterfaceType((short) 1), Guid("00000127-0000-0000-C000-000000000046")]
public interface IViewObject2 : IViewObject {
  void GetExtent([In] uint dwDrawAspect, [In] int lindex, [In] ref tagDVTARGETDEVICE ptd, out tagSIZEL lpsizel);
}


[StructLayout(LayoutKind.Sequential, Pack=4), ComConversionLoss]
public struct tagBIND_OPTS2 {
  public uint cbStruct;
  public uint grfFlags;
  public uint grfMode;
  public uint dwTickCountDeadline;
  public uint dwTrackFlags;
  public uint dwClassContext;
  public uint locale;
  [ComConversionLoss]
  public IntPtr pServerInfo;
}


public enum tagDOCHOSTUIDBLCLK {
  DOCHOSTUIDBLCLK_DEFAULT,
  DOCHOSTUIDBLCLK_SHOWPROPERTIES,
  DOCHOSTUIDBLCLK_SHOWCODE
}


public enum tagDOCHOSTUIFLAG {
  DOCHOSTUIFLAG_ACTIVATE_CLIENTHIT_ONLY = 0x200,
  DOCHOSTUIFLAG_CODEPAGELINKEDFONTS = 0x800,
  DOCHOSTUIFLAG_DIALOG = 1,
  DOCHOSTUIFLAG_DISABLE_EDIT_NS_FIXUP = 0x400000,
  DOCHOSTUIFLAG_DISABLE_HELP_MENU = 2,
  DOCHOSTUIFLAG_DISABLE_OFFSCREEN = 0x40,
  DOCHOSTUIFLAG_DISABLE_SCRIPT_INACTIVE = 0x10,
  DOCHOSTUIFLAG_DISABLE_UNTRUSTEDPROTOCOL = 0x1000000,
  DOCHOSTUIFLAG_DIV_BLOCKDEFAULT = 0x100,
  DOCHOSTUIFLAG_ENABLE_FORMS_AUTOCOMPLETE = 0x4000,
  DOCHOSTUIFLAG_ENABLE_INPLACE_NAVIGATION = 0x10000,
  DOCHOSTUIFLAG_FLAT_SCROLLBAR = 0x80,
  DOCHOSTUIFLAG_IME_ENABLE_RECONVERSION = 0x20000,
  DOCHOSTUIFLAG_LOCAL_MACHINE_ACCESS_CHECK = 0x800000,
  DOCHOSTUIFLAG_NO3DBORDER = 4,
  DOCHOSTUIFLAG_NO3DOUTERBORDER = 0x200000,
  DOCHOSTUIFLAG_NOPICS = 0x100000,
  DOCHOSTUIFLAG_NOTHEME = 0x80000,
  DOCHOSTUIFLAG_OPENNEWWIN = 0x20,
  DOCHOSTUIFLAG_OVERRIDEBEHAVIORFACTORY = 0x400,
  DOCHOSTUIFLAG_SCROLL_NO = 8,
  DOCHOSTUIFLAG_THEME = 0x40000,
  DOCHOSTUIFLAG_URL_ENCODING_DISABLE_UTF8 = 0x1000,
  DOCHOSTUIFLAG_URL_ENCODING_ENABLE_UTF8 = 0x2000
}


public enum tagDOCHOSTUITYPE {
  DOCHOSTUITYPE_BROWSE,
  DOCHOSTUITYPE_AUTHOR
}


[StructLayout(LayoutKind.Sequential, Pack=4), ComConversionLoss]
public struct tagDVTARGETDEVICE {
  public uint tdSize;
  public ushort tdDriverNameOffset;
  public ushort tdDeviceNameOffset;
  public ushort tdPortNameOffset;
  public ushort tdExtDevmodeOffset;
  [ComConversionLoss]
  public IntPtr tdData;
}


[StructLayout(LayoutKind.Sequential, Pack=4), ComConversionLoss]
public struct tagFORMATETC {
  [ComConversionLoss]
  public IntPtr cfFormat;
  [ComConversionLoss]
  public IntPtr ptd;
  public uint dwAspect;
  public int lindex;
  public uint tymed;
}


[StructLayout(LayoutKind.Sequential, Pack=2), ComConversionLoss]
public struct tagLOGPALETTE {
  public ushort palVersion;
  public ushort palNumEntries;
  [ComConversionLoss]
  public IntPtr palPalEntry;
}


[StructLayout(LayoutKind.Sequential, Pack=4), ComConversionLoss]
public struct tagMSG {
  [ ComConversionLoss]
  public IntPtr hwnd;
  public uint message;
  public uint wParam;
  public int lParam;
  public uint time;
  public tagPOINT pt;
}


[StructLayout(LayoutKind.Sequential, Pack=4)]
public struct tagOleMenuGroupWidths {
  [MarshalAs(UnmanagedType.ByValArray, SizeConst=6)]
  public int[] width;
}


[StructLayout(LayoutKind.Sequential, Pack=1)]
public struct tagPALETTEENTRY {
  public byte peRed;
  public byte peGreen;
  public byte peBlue;
  public byte peFlags;
}


[StructLayout(LayoutKind.Sequential, Pack=4)]
public struct tagPOINT {
  public int x;
  public int y;
}


[StructLayout(LayoutKind.Sequential, Pack=4)]
public struct tagRECT {
  public int left;
  public int top;
  public int right;
  public int bottom;
}


[StructLayout(LayoutKind.Sequential, Pack=4)]
public struct tagSIZEL {
  public int cx;
  public int cy;
}


[StructLayout(LayoutKind.Sequential, Pack=4)]
public struct tagSTATDATA {
  public tagFORMATETC formatetc;
  public uint advf;
  [MarshalAs(UnmanagedType.Interface)]
  public IAdviseSink pAdvSink;
  public uint dwConnection;
}


[StructLayout(LayoutKind.Sequential, Pack=8)]
public struct tagSTATSTG {
  [MarshalAs(UnmanagedType.LPWStr)]
  public string pwcsName;
  public uint type;
  public _ULARGE_INTEGER cbSize;
  public _FILETIME mtime;
  public _FILETIME ctime;
  public _FILETIME atime;
  public uint grfMode;
  public uint grfLocksSupported;
  public Guid clsid;
  public uint grfStateBits;
  public uint reserved;
}


[StructLayout(LayoutKind.Sequential, Pack=4), ComConversionLoss]
public struct _BYTE_BLOB {
  public uint clSize;
  [ComConversionLoss]
  public IntPtr abData;
}


[StructLayout(LayoutKind.Sequential, Pack=4), ComConversionLoss]
public struct _COAUTHIDENTITY {
  [ComConversionLoss]
  public IntPtr User;
  public uint UserLength;
  [ComConversionLoss]
  public IntPtr Domain;
  public uint DomainLength;
  [ComConversionLoss]
  public IntPtr Password;
  public uint PasswordLength;
  public uint Flags;
}


[StructLayout(LayoutKind.Sequential, Pack=4), ComConversionLoss]
public struct _COAUTHINFO {
  public uint dwAuthnSvc;
  public uint dwAuthzSvc;
  [MarshalAs(UnmanagedType.LPWStr)]
  public string pwszServerPrincName;
  public uint dwAuthnLevel;
  public uint dwImpersonationLevel;
  [ComConversionLoss]
  public IntPtr pAuthIdentityData;
  public uint dwCapabilities;
}


[StructLayout(LayoutKind.Sequential, Pack=4), ComConversionLoss]
public struct _COSERVERINFO {
  public uint dwReserved1;
  [MarshalAs(UnmanagedType.LPWStr)]
  public string pwszName;
  [ComConversionLoss]
  public IntPtr pAuthInfo;
  public uint dwReserved2;
}


[StructLayout(LayoutKind.Sequential, Pack=4), ComConversionLoss]
public struct _DOCHOSTUIINFO {
  public uint cbSize;
  public uint dwFlags;
  public uint dwDoubleClick;
  [ComConversionLoss]
  public IntPtr pchHostCss;
  [ComConversionLoss]
  public IntPtr pchHostNS;
}


[StructLayout(LayoutKind.Sequential, Pack=4)]
public struct _FILETIME {
  public uint dwLowDateTime;
  public uint dwHighDateTime;
}


[StructLayout(LayoutKind.Sequential, Pack=4), ComConversionLoss]
public struct _FLAGGED_BYTE_BLOB {
  public uint fFlags;
  public uint clSize;
  [ComConversionLoss]
  public IntPtr abData;
}


[StructLayout(LayoutKind.Sequential, Pack=4)]
public struct _GDI_OBJECT {
  public uint ObjectType;
  public __MIDL_IAdviseSink_0002 u;
}


[StructLayout(LayoutKind.Sequential, Pack=8)]
public struct _LARGE_INTEGER {
  public long QuadPart;
}


[StructLayout(LayoutKind.Sequential, Pack=4)]
public struct _POINTL {
  public int x;
  public int y;
}


[StructLayout(LayoutKind.Sequential, Pack=4)]
public struct _RECTL {
  public int left;
  public int top;
  public int right;
  public int bottom;
}


[StructLayout(LayoutKind.Sequential, Pack=4)]
public struct _RemotableHandle {
  public int fContext;
  public __MIDL_IWinTypes_0009 u;
}


[StructLayout(LayoutKind.Sequential, Pack=4), ComConversionLoss]
public struct _remoteMETAFILEPICT {
  public int mm;
  public int xExt;
  public int yExt;
  [ComConversionLoss]
  public IntPtr hMF;
}


[StructLayout(LayoutKind.Sequential, Pack=4)]
public struct _STGMEDIUM_UNION {
  public uint tymed;
  public __MIDL_IAdviseSink_0003 u;
}


[StructLayout(LayoutKind.Sequential, Pack=4)]
public struct _tagOLECMD {
  public uint cmdID;
  public uint cmdf;
}


[StructLayout(LayoutKind.Sequential, Pack=4), ComConversionLoss]
public struct _tagOLECMDTEXT {
  public uint cmdtextf;
  public uint cwActual;
  public uint cwBuf;
  [ComConversionLoss]
  public IntPtr rgwz;
}


[StructLayout(LayoutKind.Sequential, Pack=8)]
public struct _ULARGE_INTEGER {
  public ulong QuadPart;
}


[StructLayout(LayoutKind.Sequential, Pack=4), ComConversionLoss]
public struct _userBITMAP {
  public int bmType;
  public int bmWidth;
  public int bmHeight;
  public int bmWidthBytes;
  public ushort bmPlanes;
  public ushort bmBitsPixel;
  public uint cbSize;
  [ComConversionLoss]
  public IntPtr pBuffer;
}


[StructLayout(LayoutKind.Sequential, Pack=4)]
public struct _userCLIPFORMAT {
  public int fContext;
  public __MIDL_IWinTypes_0001 u;
}


[StructLayout(LayoutKind.Sequential, Pack=4)]
public struct _userFLAG_STGMEDIUM {
  public int ContextFlags;
  public int fPassOwnership;
  public _userSTGMEDIUM Stgmed;
}


[StructLayout(LayoutKind.Sequential, Pack=8)]
public struct _userHBITMAP {
  public int fContext;
  public __MIDL_IWinTypes_0007 u;
}


[StructLayout(LayoutKind.Sequential, Pack=8)]
public struct _userHENHMETAFILE {
  public int fContext;
  public __MIDL_IWinTypes_0006 u;
}


[StructLayout(LayoutKind.Sequential, Pack=8)]
public struct _userHGLOBAL {
  public int fContext;
  public __MIDL_IWinTypes_0003 u;
}


[StructLayout(LayoutKind.Sequential, Pack=8)]
public struct _userHMETAFILE {
  public int fContext;
  public __MIDL_IWinTypes_0004 u;
}


[StructLayout(LayoutKind.Sequential, Pack=8)]
public struct _userHMETAFILEPICT {
  public int fContext;
  public __MIDL_IWinTypes_0005 u;
}


[StructLayout(LayoutKind.Sequential, Pack=8)]
public struct _userHPALETTE {
  public int fContext;
  public __MIDL_IWinTypes_0008 u;
}


[StructLayout(LayoutKind.Sequential, Pack=4)]
public struct _userSTGMEDIUM {
  public _STGMEDIUM_UNION __MIDL_0003;
  [MarshalAs(UnmanagedType.IUnknown)]
  public object pUnkForRelease;
}


[StructLayout(LayoutKind.Explicit, Size=4, Pack=4)]
public struct __MIDL_IAdviseSink_0002 {
}


[StructLayout(LayoutKind.Explicit, Size=4, Pack=4)]
public struct __MIDL_IAdviseSink_0003 {
}


[StructLayout(LayoutKind.Explicit, Size=4, Pack=4)]
public struct __MIDL_IWinTypes_0001 {
}


[StructLayout(LayoutKind.Explicit, Size=8, Pack=8)]
public struct __MIDL_IWinTypes_0003 {
}


[StructLayout(LayoutKind.Explicit, Size=8, Pack=8)]
public struct __MIDL_IWinTypes_0004 {
}


[StructLayout(LayoutKind.Explicit, Size=8, Pack=8)]
public struct __MIDL_IWinTypes_0005 {
}


[StructLayout(LayoutKind.Explicit, Size=8, Pack=8)]
public struct __MIDL_IWinTypes_0006 {
}


[StructLayout(LayoutKind.Explicit, Size=8, Pack=8)]
public struct __MIDL_IWinTypes_0007 {
}


[StructLayout(LayoutKind.Explicit, Size=8, Pack=8)]
public struct __MIDL_IWinTypes_0008 {
}


[StructLayout(LayoutKind.Explicit, Pack=4)]
public struct __MIDL_IWinTypes_0009 {
  [FieldOffset(0)]
  public int hInproc;
  [FieldOffset(0)]
  public int hRemote;
}


class IECaptUIHandler : IDocHostUIHandler {

  public uint ShowContextMenu(uint dwID, ref tagPOINT ppt, object pcmdtReserved, object pdispReserved) {
    return 1;
  }

  public void GetHostInfo(ref _DOCHOSTUIINFO pInfo) {
    pInfo.cbSize = (uint)Marshal.SizeOf(pInfo);
    pInfo.dwDoubleClick = 0;
    pInfo.pchHostCss = (IntPtr)0;
    pInfo.pchHostNS = (IntPtr)0;
    pInfo.dwFlags = (uint)(0
      | tagDOCHOSTUIFLAG.DOCHOSTUIFLAG_SCROLL_NO
      | tagDOCHOSTUIFLAG.DOCHOSTUIFLAG_NO3DBORDER
      | tagDOCHOSTUIFLAG.DOCHOSTUIFLAG_NO3DOUTERBORDER
    );
  }

  public uint ShowUI(uint dwID, IOleInPlaceActiveObject pActiveObject, IOleCommandTarget pCommandTarget, IOleInPlaceFrame pFrame, IOleInPlaceUIWindow pDoc) {
    return 1;
  }

  public void HideUI() {
    throw new NotImplementedException();
  }

  public void UpdateUI() {
    throw new NotImplementedException();
  }

  public void EnableModeless(int fEnable) {
    throw new NotImplementedException();
  }

  public void OnDocWindowActivate(int fActivate) {
    throw new NotImplementedException();
  }

  public void OnFrameWindowActivate(int fActivate) {
    throw new NotImplementedException();
  }

  public void ResizeBorder(ref tagRECT prcBorder, IOleInPlaceUIWindow pUIWindow, int fRameWindow) {
    throw new NotImplementedException();
  }

  public void TranslateAccelerator(ref tagMSG lpmsg, ref Guid pguidCmdGroup, uint nCmdID) {
    throw new NotImplementedException();
  }

  public void GetOptionKeyPath(out string pchKey, uint dw) {
    pchKey = null;
    throw new NotImplementedException();
  }

  public void GetDropTarget(IDropTarget pDropTarget, out IDropTarget ppDropTarget) {
    ppDropTarget = null;
    throw new NotImplementedException();
  }

  public void GetExternal(out object ppDispatch) {
    ppDispatch = null;
    throw new NotImplementedException();
  }

  public uint TranslateUrl(uint dwTranslate, string pchURLIn, ref string ppchURLOut) {
    return 1;
  }

  public uint FilterDataObject(IDataObject pDO, out IDataObject ppDORet) {
    ppDORet = null;
    return 1;
  }
}

class IECaptForm : Form {
  private string mURL;
  private string mFile;
  private int mMinWidth;
  private AxWebBrowser mWb;
  public Timer mTimer = new Timer();

  public IECaptForm(string url, string file, int minWidth, int delay, AxWebBrowser wb) {
    mURL = url;
    mFile = file;
    mMinWidth = minWidth;
    mTimer.Interval = delay;
    mTimer.Tick += new EventHandler(mTimer_Tick);
    mWb = wb;
  }

  private void mTimer_Tick(object sender, EventArgs e) {
    mTimer.Stop();

    try {
      DoCapture();
    } 
    catch (Exception ex) {
      Console.WriteLine(ex.Message);
    }

    mWb.Dispose();
    Application.Exit();
  }

  public void DoCapture() {
    IHTMLDocument2 doc2 = (IHTMLDocument2)mWb.Document;
    IHTMLDocument3 doc3 = (IHTMLDocument3)mWb.Document;
    IHTMLElement2 body2 = (IHTMLElement2)doc2.body;
    IHTMLElement2 root2 = (IHTMLElement2)doc3.documentElement;

    // Determine dimensions for the image; we could add minWidth here
    // to ensure that we get closer to the minimal width (the width
    // computed might be a few pixels less than what we want).
    int width = Math.Max(body2.scrollWidth, root2.scrollWidth);
    int height = Math.Max(root2.scrollHeight, body2.scrollHeight);

    // Resize the web browser control
    mWb.SetBounds(0, 0, width, height);

    // Do it a second time; in some cases the initial values are
    // off by quite a lot, for as yet unknown reasons. We could
    // also do this in a loop until the values stop changing with
    // some additional terminating condition like n attempts.
    width = Math.Max(body2.scrollWidth, root2.scrollWidth);
    height = Math.Max(root2.scrollHeight, body2.scrollHeight);
    mWb.SetBounds(0, 0, width, height);

    Bitmap image = new Bitmap(width, height);
    Graphics g = Graphics.FromImage(image);

    _RECTL bounds;
    bounds.left = 0;
    bounds.top = 0;
    bounds.right = width;
    bounds.bottom = height;

    IntPtr hdc = g.GetHdc();
    IViewObject iv = doc2 as IViewObject;

    // TODO: Write to Metafile instead if requested.

    iv.Draw(1, -1, (IntPtr)0, (IntPtr)0, (IntPtr)0,
      (IntPtr)hdc, ref bounds, (IntPtr)0, (IntPtr)0, 0);

    g.ReleaseHdc(hdc);
    image.Save(mFile);
    image.Dispose();
  }

}

class IECapt {

  static void PrintUsage() {
    Console.WriteLine("Usage: IECapt --url=http://... --out=file.png");
    Console.WriteLine();
    Console.WriteLine("Options:");
    Console.WriteLine("  --url         The URL to capture");
    Console.WriteLine("  --out         The target file (.png|jpeg|bmp|emf|tiff)");
    Console.WriteLine("  --min-width   Minimal width for the image (default: 800)");
 // Console.WriteLine("  --max-height   Maximal height to capture (default: 0)");
 // Console.WriteLine("" --user-style   Path to user style sheet (.css) file");
    Console.WriteLine("  --delay       Capturing delay in ms (default: 1)");
  }

  [STAThread]
  static void Main(string[] args) {
    string URL = null;
    string file = null;
    int minWidth = 800;
    int delay = 1;

    if (args.Length == 0) {
      PrintUsage();
      return;
    }

    // Parse command line parameters
    foreach (string arg in args) {
      string[] tmp = arg.Split(new char[]{ '=' }, 2);

      if (tmp.Length < 2) {
        PrintUsage();
        return;
      } else if (tmp[0].Equals("--url")) {
        URL = tmp[1];
      } else if (tmp[0].Equals("--out")) {
        file = tmp[1];;
      } else if (tmp[0].Equals("--min-width")) {
        minWidth = int.Parse(tmp[1]);
      } else if (tmp[0].Equals("--delay")) {
        delay = int.Parse(tmp[1]);
      } else {
        Console.WriteLine("Warning: unknown parameter {0}", tmp[0]);
      }
    }

    if (delay < 1 || URL == null || file == null) {
      PrintUsage();
      return;
    }

    AxWebBrowser wb = new AxWebBrowser();
    Form main = new IECaptForm(URL, file, minWidth, delay, wb);

    wb.BeginInit();
    wb.Parent = main;
    wb.EndInit();

    // Set the initial dimensions of the browser's client area.
    wb.SetBounds(0, 0, minWidth, 600);

    object oBlank = "about:blank";
    object oURL = URL;
    object oNull = String.Empty;

    // Internet Explorer should show no dialog boxes; this does not dis-
    // able script debugging however, I am not aware of a method to dis-
    // able that, other than manual configuration in he Internet Settings
    // or perhaps the registry.
    wb.Silent = true;

    // The custom UI handler can only be registered on a document, so we
    // navigate to about:blank as a first step, then register the handler.
    wb.Navigate2(ref oBlank, ref oNull, ref oNull, ref oNull, ref oNull);

    ICustomDoc cdoc = wb.Document as ICustomDoc;
    cdoc.SetUIHandler(new IECaptUIHandler());

    // Register a document complete handler. It will be called whenever a
    // document completes loading, including embedded documents and the
    // initial about:blank document.
    wb.DocumentComplete +=
      new DWebBrowserEvents2_DocumentCompleteEventHandler(IE_DocumentComplete);

    // Register an error handler. If the main document cannot be loaded,
    // the document complete event will not fire, so we have to listen to
    // this and shut the application down in case of a fatal error.
    wb.NavigateError +=
      new DWebBrowserEvents2_NavigateErrorEventHandler(IE_NavigateError);

    // Now navigate to the final destination.
    wb.Navigate2(ref oURL, ref oNull, ref oNull, ref oNull, ref oNull);

    Application.Run();
  }

  private static void IE_DocumentComplete(object sender,
    DWebBrowserEvents2_DocumentCompleteEvent e) {

    AxWebBrowser wb = (AxWebBrowser)sender;
    IECaptForm main = (IECaptForm)wb.Parent;

    // Skip document complete event for embedded frames.
    if (wb.Application != e.pDisp)
      return;

    // Skip the initial about:blank document; this is not necessarily
    // the best thing to do, e.g. if the requested page is about:blank
    // or redirects to it, we might never exit. This could be avoided
    // by remembering whether we saw the first document complete event.
    if (e.uRL.Equals("about:blank"))
      return;

    main.mTimer.Start();
  }

  private static void IE_NavigateError(object sender, DWebBrowserEvents2_NavigateErrorEvent e) {
    AxWebBrowser wb = (AxWebBrowser)sender;
    IECaptForm main = (IECaptForm)wb.Parent;

    // Ignore errors for embedded documents
    if (wb.Application != e.pDisp)
      return;

    // If we get here, the main document cannot be navigated 
    // to meaning there is nothing to draw, so we just croak.
    Console.Error.WriteLine("Failed to navigate to {0} (0x{1:X08})",
      e.uRL, e.statusCode);

    wb.Dispose();
    Application.Exit();
  }
}
